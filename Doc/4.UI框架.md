## UI框架

### 需求分析

以UI框架功能需求为例，我们有以下几个问题需要用框架来解决：

1. 游戏中的多个场景会反复出现相同的“UI窗体”，造成多个场景中反复加载相同的UI窗体。这个时候，就需要“UI框架” 缓存项目中常用的“UI窗体"，以避免每切换一个场景都需要重新加载UI窗体。  
2. 开发商业复杂项目时，各个UI脚本之间传值，容易出现“紧耦合”的情况，容易导致项目的“可复用性”降低。 如果各个UI的生成、销毁、切换，都是通过框架(Manger)实现，各个UI之间不直接联系（传值），开发类似“消息传递中心”的机制来负责所有“UI窗体”或者UI脚本之间的传值，就可以避免这样的情况。 
3. 卡牌、RPG等游戏类型项目，很多情况下会出现多个“弹出窗体” 叠加的现象，开发人员需要“手工”维护窗体中间的层级关系，这样无疑会增加游戏维护的难度。 而如果我们设计UI框架系统，使用“栈”的数据结构，就可以用程序自动保存与控制当前所有需要显示的“UI窗体”的层级关系 ，同时也避免了“手工”方式容易产生的失误问题。
4. 商业项目中多个“UI窗体” 叠加出现时，保持“UI窗体”的“模态显示”非常重要（即： 弹出子窗口时，不允许玩家操作父窗体），否则容易出现各种误操作。解决方案是：设计的框架本身，需要对当前显示的窗体做“遮挡处理”，即：不允许用户绕过当前“UI窗体”直接操作底层窗体，或者误操作点击项目中的3D游戏对象等。 

### 框架设计与实现

UI框架支持栈缓存，智能层级控制，模态窗体管理等功能。将UI框架融入到SFramework这个大框架中，使用外观模式，专门管理游戏中的UI，可以非常方便的通过接口调用打开关闭UI。

UI框架主要由Common、ViewBase、UIManager等类构成。

------

##### Common 框架核心参数 
我们在Common类中定义UI框架的参数：UI枚举类型+路径常量

定义系统三个枚举类型，这3个枚举类型将UI设置分好类，位置，显示，遮罩

**UIFormType** 窗体类型

Normal普通窗体，Fixed固定窗体（非全屏非弹出窗体，位置在普通窗体之上），Popup弹出窗体（需要放在最前显示）

**UIFormShowMode **显示类型

Normal普通（可以与其他窗体并列显示的窗体），ReverseChange反向切换（用于弹出窗体，栈存储，即要求玩家必须先关闭弹出的顶层窗体，再依次关闭下一级窗体），HideOther隐藏其他（通常用于全屏窗体）

**UIFormLucenyType** 透明度类型

Lucency完全透明、不能穿透，Translucence半透明、不能穿透，ImPenetrable低透明、不能穿透，Pentrate可以穿透4种。

------

##### ViewBase UI继承的基类

设计每个UI都需要继承一个基类，并设置其默认属性，包括窗体类型、显示类型、透明度类型。

每个UI提供4种生命周期状态供框架调用：

- Display
- Hiding
- Redisplay
- Freeze

Popup的生命周期状态调用与其他相比要多调用一个遮罩

封装常用的UI事件方法：

- ShowText 多语言本地化显示Text
- OpenUIForm 调用UIManager打开UI窗体
- CloseUIForm

------

##### UIManager UI的管理者

简介：UI管理器，管理游戏中的所有UI窗体，智能控制各UI的层级，生命周期，实现栈存储。

作用：整个UI框架的核心，用户程序通过本脚本，来实现框架绝大多数的功能实现。

属性-CanvasGO,UICamera,UIMaskMgr

3个字典缓存 窗体预设路径，所有UI，当前显示的UI

方法-ShowUIForms，CloseUIForms

能够智能自动读取UI文件路径，只需将UI原型放在放在Resources\UI文件夹下，即可直接使用UI文件名加载预设的UI。这个我们使用了C#目录扫描和资源加载系统来实现。

在第一次加载UI的时候，UIManager会预先创建一个Canvas单例，作为存放UI窗体的画布，之后加载的UI都会根据该UI设置的属性，摆放在画布相应的层级结构中，后加载的窗体需要放置在先加载的窗体的前方。

UIManager维护了allUIFormsDict和currentShowUIFormsDict字典，分别存放已加载的UI窗体和目前显示的UI窗体。另外还使用了一个栈来专门存储当前所有需要”反向切换“的窗体类型，并封装了打开和关闭“反向切换”窗体时，进出栈需要执行的具体逻辑。

同样的，对于需要“隐藏其他”类型的窗体，加载后会将其他窗体切换为隐藏状态，当关闭该窗体时，再把其他窗体切换为显示状态。对于需要“UI遮罩”的窗体，我们会在该窗体的层级下加载一个遮罩UI“Panel”，以阻挡玩家点击非法位置，并根据设置的透明度计算Panel显示的透明度，关闭该窗体的同时也会使遮罩失效。

##### UIMaskMgr UI遮罩管理器 

负责“弹出窗体”模态显示实现

UIMaskMgr是为UIManager所使用的，不需要显式调用

方法-SetMaskWindow，CancelMaskWindow

现已将UIMgr和UIMaskMgr相互引用，一同赋值给各个UI

## UI框架的使用

我们提供了一个默认的Canvas，放在Resources文件夹下，Canvas下的UI会分别保存在Normal, Fixed, Popup层级下。

    1. 将你所需要显示的UI保存为Prefab，将其路径加入UIManager字典集中管理（现已支持智能自动读取UI文件路径，直接将UI的Prefab存放到Resources\UI文件夹下即可）
    2. 创建UI脚本，继承ViewBase，使用SFramework命名空间，放在项目命名空间下，设置具体的UI行为
    3. 写好button等的事件，调用UIManager的方法ShowUIForms和CloseUIForms来开关UI
    4. 这样每次只需要在当前UI脚本中写好要调用的方法和UI名称，而不用管UI对象是什么类型，就可以实现UI切换了（底层由UIManager自动管理）



